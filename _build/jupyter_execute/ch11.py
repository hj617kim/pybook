#!/usr/bin/env python
# coding: utf-8

# # 리스트

# 개별 데이터를 따로따로 처리하기 보다는 하나로 묶어서 처리해야 편리한 경우가 있다. 파이썬은 많은 데이터를 하나로 묶어서 처리할 수 있는 다양한 자료형을 제공하는데, 여기서는 리스트 자료형을 살펴보자. 

# **리스트**<font size="2">list</font>는 파이썬에서 사용할 수 있는 **임의의** 값들을 모아서 하나의 값으로 취급하는 자료형으로, 리스트의 형식은 다음과 같다.  
# 
# > [항목1, 항목2, 항목3, ..., 항목n]
# 
# 대괄호(`[]`)를 사용하고, 각 항목은 콤마(,)로 구분한다. 
# 
# 

# 예를 들어, 1부터 10이하의 짝수를 담은 리스트 `even_numbers`를 만드는 코드는 아래와 같다.

# In[1]:


even_numbers = [2, 4, 6, 8, 10]


# 비슷하게, 문자열 a, b, c를 담은 리스트 `list_abc`는 아래와 같다.

# In[2]:


list_abc = ['a', 'b', 'c']


# 
# 
# 리스트는 아래와 같이 서로 다른 자료형의 항목들을 포함할 수 있지만, 항목들이 모두 같은 자료형인 경우를 많이 사용한다. 

# In[3]:


mixed_list = [1, 3.5, "abc", True, [1, 2]]
mixed_list


# 참고) 리스트는 중첩을 허용한다. 위의 `mixed_list`의 다섯째 항목은 리스트`[1, 2]` 이다. 

# 리스트에 포함된 항목들 사이의 순서는 중요하다. 리스트 항목의 순서 또는 개수가 다르면 서로 다른 것으로 처리된다.

# In[4]:


[1, 2] == [2, 1]


# In[5]:


[1] == [1, 1]


# ## 리스트 연산
# 
# 리스트는 사칙연산 중 덧셈과 곱셈 연산자를 사용할 수 있다. 

# In[6]:


[1, 2] + [2, 3, 4]


# In[7]:


[1, 2, 3] * 3


# ## 리스트의 길이
# 
# 리스트의 길이는 `len()` 함수를 이용하여 확인할 수 있다. 

# In[8]:


len([1, 2])


# In[9]:


list_abc = ["a", "b", "c"]
len(list_abc)


# ## 리스트의 인덱싱과 슬라이싱
# 
# 리스트도 문자열처럼 인덱싱과 슬라이싱이 가능하다. 

# ### 인덱싱

# 인덱스는 0부터 시작하며, 오른쪽으로 한 항목씩 이동할 때마다 증가한다.  
# 
# 예제를 통해 살펴보자.

# In[10]:


a = [1, 2, 3, 4, 5]
a


# 특정 인덱스에 위치한 항목의 정보는 다음과 같이 확인한다. 
# 
# * 0번 인덱스 값, 즉 첫째 항목

# In[11]:


a[0]


# * 1번 인덱스 값, 즉 둘째 항목

# In[12]:


a[1]


# * -1번 인덱스 값, 즉 가장 오른쪽 항목

# In[13]:


a[-1]


# 등등.  
# 
# 문자열과 마찬가지로, 리스트의 길이보다 같거나 큰 인덱스를 사용하면 오류가 발생한다. 리스트의 길이는 `len()` 함수를 이용하여 확인할 수 있다.

# ```python
# >>> a[10]
# ---------------------------------------------------------------------------
# IndexError                                Traceback (most recent call last)
# <ipython-input-14-7c7cb9812849> in <module>()
# ----> 1 a[10]
# 
# IndexError: list index out of range
# ```

# 0번 인덱스 값 `a[0]`와 2번 인덱스 값 `a[2]`를 더하고 싶다면 아래와 같이 하면 된다. 
# 

# In[14]:


a[0] + a[2]


# 주의) `a[0]`와 `a[2]`의 자료형은 정수형으로 덧셈 연산이 가능하다.

# In[15]:


print(type(a[0]))
print(type(a[2]))


# ````{prf:example}
# :label: list_ex01
# 리스트는 중첩을 허용한다. 아래 리스트는 3중 리스트이다. 
# 
# `a_nested_list = [1, 2, [3, 4], [[5, 6, 7], 8]]`
# ````

# * 위 리스트에서 2를 인덱스로 얻는 방법은?

# In[16]:


a_nested_list = [1, 2, [3, 4], [[5, 6, 7], 8]]
a_nested_list[1]


# * `[3, 4]`를 인덱스로 얻는 방법은?

# In[17]:


a_nested_list[2]


# * `3`을 인덱스로 얻는 방법은?

# 인덱스를 연속해서 적용하면 된다.

# In[18]:


a_nested_list[2][0]


# * `[5, 6, 7]`을 인덱스로 얻는 방법은?

# In[19]:


a_nested_list[3][0]


# * `7`을 인덱스로 얻는 방법은?

# In[20]:


a_nested_list[3][0][2]


# **빈 리스트**  
# 빈 리스트는 아무 것도 포함하지 않는 리스트를 의미한다. 
# 빈 리스트는 아래와 같이 작성할 수 있다. 

# In[21]:


empty_list = []
empty_list1 = list()


# 빈 리스트의 길이는 0이다.

# In[22]:


len(empty_list)


# 빈 리스트는 아무 것도 포함하지 않는다. 따라서 0번 인덱스 값도 없다.  
# 
# ```python
# >>> empty_list[0]
# ---------------------------------------------------------------------------
# IndexError                                Traceback (most recent call last)
# <ipython-input-24-dcfcc1be2c42> in <module>()
# ----> 1 empty_list[0]
# 
# IndexError: list index out of range
# ```

# 주의) 반면에 아래 리스트는 빈 리스트가 아니다.

# In[23]:


a_singleton = [[]]


# 위 리스트는 빈 리스트를 포함한 리스트이다. 따라서 길이가 1이다. 

# In[24]:


len(a_singleton)


# 포함된 유일한 항목은 빈 리스트이다.

# In[25]:


a_singleton[0]


# [note] `list()` 함수의 인자로 문자열을 넣으면, 각 문자를 항목으로 갖는 리스트를 반환한다. 

# In[26]:


list('abcde')


# ### 슬라이싱

# 문자열과 마찬가지로 리스트에서도 슬라이싱을 할 수 있다. 사용법도 동일하다.  
# 예제를 통해서 살펴보자. 

# In[27]:


a = [1, 2, 3, 4, 5]

a[0 : 2] # 처음부터 2번 인덱스 전까지 추출


# In[28]:


b = a[0 : 2]  # 변수 b에 할당
print(b)
print(type(b))  # 자료형은 리스트


# In[29]:


a[2 : ]  # 2번 인덱스부터 끝까지 추출


# In[30]:


a[ : 2]  # 처음부터 2번 인덱스 전까지 추출


# 중첩 리스트에서도 슬라이싱 방법은 똑같이 적용된다. 

# In[31]:


c = [1, 2, [3, 4], [[5, 6], 7, 8, 9]]
c[1 : 3] # 1번 인덱스 값과 2번 인덱스 값을 포함한 리스트 


# In[32]:


c[3][2: ] # c[3]은 [[5, 6], 7, 8, 9]이다.


# ## 가변 자료형
# 
# 파이썬의 문자열 자료형의 값들은 한 번 정해지면 변경이 불가능하다. 반면 리스트는 수정 가능하다. 이러한 자료형을 가변자료형이라 부른다. 
# 
# 예를 들어, 앞에서 배운 인덱싱과 슬라이싱을 사용하여 수정할 수 있다. 

# In[33]:


a = [1, 2, 3, 4, 5]
a


# 인덱싱을 사용하여 아래와 같이 `a[1]`을 `2`에서 `10`으로 변경할 수 있다. 

# In[34]:


a[1] = 10
a


# 슬라이싱을 사용하여 2번 인덱스 값부터 4번 인덱스 값 전까지를 11과 12로 변경해보자. 

# In[35]:


a[2:4] = [11, 12]
a


# 한편, 슬라이싱을 사용하여 2번 인덱스 값부터 5번 인덱스 값 전까지를 11과 12로 변경하면, 아래와 같다.

# In[36]:


a = [1, 2, 3, 4, 5]
a[2 : 5] = [11, 12]
a


# :::{admonition} 주의  
# :class: caution  
# 문자열은 인덱싱과 슬라이싱을 사용하여 값을 변경할 수 없다.
# ```python
# >>> a_word = "hello"
# >>> print(a_word[0])
# h
# >>> a_word[0] = "H"
# ---------------------------------------------------------------------------
# TypeError                                 Traceback (most recent call last)
# <ipython-input-39-f2dd4f08a29e> in <module>()
# ----> 1 a_word[0] = "H"
# 
# TypeError: 'str' object does not support item assignment
# ```
# :::
# 

# **인덱싱과 슬라이싱의 차이**
# 
# 인덱싱과 슬라이싱은 작동방식이 다르다. 예제를 통해 살펴보자.  
# 
# 동물들의 리스트 `animals`를 아래와 같이 정의하자.

# In[37]:


animals = ['dog', 'cat', 'pig']


# 이제 인덱싱을 사용하여 1번 인덱스 값으로 `cat` 대신 새로운 리스트인 `['tiger', 'lion', 'rabbit']`를 지정해보자. 

# In[38]:


animals[1] = ['tiger', 'lion', 'rabbit']


# 그러면 `animals`는 2중 리스트가 된다.

# In[39]:


animals


# 반면에 아래와 같이 슬라이싱을 사용하면 전혀 다른 결과를 얻는다.

# In[40]:


animals = ['dog', 'cat', 'pig']
animals[1:2] = ['tiger', 'lion', 'rabbit']


# 슬라이싱을 활용하면 2중 리스트 대신에 확장된 리스트를 얻게 된다.

# In[41]:


animals


# 슬라이싱을 활용하여 특정 항목을 삭제할 수도 있다. 예를 들어, 2번과 3번 인덱스 값인 `tiger`와 `lion`을 삭제하고 싶다면 아래와 같이 할 수 있다. 

# In[42]:


animals[2:4] = []
animals


# ## 리스트 관련 메소드
# 
# 여기서는 많이 사용되는 리스트와 관련된 메소드를 몇 개 소개한다.
# 
# * `append()`
# * `extend()`
# * `remove()`
# * `index()`
# * `pop()`
# * `insert()`
# * `reverse()`
# * `sort()`
# * `count()`
# 
# 그리고 `del` 함수를 소개한다. 

# 예제를 통해 각 메소드의 활용법을 간략하게 확인한다.  
# 먼저, `animals` 변수에 동물들을 저장한다.

# In[43]:


animals = ['dog', 'cat', 'pig']


# * `append()` 메소드는 리스트의 끝에 항목을 하나 추가한다. 

# In[44]:


animals.append('tiger')
animals


# 주의) 동시에 여러 개의 항목을 추가할 때 `append()` 메소드를 아래처럼 이용하면 된다고 생각하면 안된다. 

# In[45]:


animals.append(['eagle', 'bear'])
animals


# 위에서는 원래의 리스트에 다른 리스트 하나를 마지막 항목으로 추가한 것이다.  
# 이것이 아니라 `eagle`과 `bear` 두 개의 항목을 원래의 리스트에 추가하고자 한다면, `append()` 메소드를 두 번 적용하거나 아니면 `extend()` 메소드를 사용하면 된다.

# * `extend()` 메소드는 리스트를 연결하여 확장시켜준다. 

# In[46]:


animals = ['dog', 'cat', 'pig']
animals.extend(['eagle', 'bear'])
animals


# 두 개의 리스트를 덧셈 기호를 이용하여 확장할 수도 있지만, 원래의 리스트를 변경하는 것이 아니라 새로운 리스트를 생성한다. 
# 
# 

# * `index()` 메소드는 리스트에 포함된 항목의 인덱스를 리턴한다.

# In[47]:


animals.index('pig')


# 참고) 문자열에도 `index()` 메소드가 있고, 사용 방법은 동일하다.

# In[48]:


"Hello, world".index('w')


# 주의) 만약에 `pig`가 여러 번 포함되어 있다면, `index()` 메소드는 가장 작은 인덱스를 리턴한다.

# In[49]:


animals.append('pig') 
animals


# In[50]:


animals.index('pig')


# * `insert()` 메소드는 특정 인덱스 위치에 항목을 삽입한다. 

# In[51]:


animals.insert(3, 'hamster')
animals


# * `remove()` 메소드는 리스트에서 첫 번째로 나오는 항목을 삭제한다.

# In[52]:


animals.remove('pig')


# In[53]:


animals


# :::{admonition} 주의   
# :class: caution  
# `remove()`, `index()` 등은 삭제 또는 찾고자 하는 항목이 없을 경우 오류를 발생시킨다.
# 
# ```python
# >>> animals.remove('leopard')
# ---------------------------------------------------------------------------
# ValueError                                Traceback (most recent call last)
# <ipython-input-61-0b619603060a> in <module>()
# ----> 1 animals.remove('leopard')
# 
# ValueError: list.remove(x): x not in list
# ```
# :::
# 

# * `pop()` 메소드는 인자가 없을 경우 맨 끝에 위치한 항목을 삭제하며, 인덱스를 인자로 사용하면 해당 항목을 삭제한다.  
# 주의) 인덱스 번호를 모를 경우에 특정 항목을 삭제하고자 한다면, `remove()` 메소드를 사용한다.

# In[54]:


animals.pop()


# In[55]:


animals


# In[56]:


animals.pop(2)


# In[57]:


animals


# 주의) 각 메소드의 리턴값에 주의해야 한다.
# * `pop()` : 리스트에서 삭제한 항목을 리턴한다.
# * `append()`, `remove()`, `insert()` 등은 기존의 리스트를 변경하지만 리턴값은 `None`, 즉 아무 것도 리턴하지 않는다.

# 이외에도 `del` 함수를 이용하여 리스트의 일부 또는 전체를 삭제할 수 있다.  
# 주의) `del` 함수(메소드 아님)는 매우 주의해서 사용해야 한다. 잘못하면 데이터 자체를 메모리에서 삭제시킬 수도 있다. 

# In[58]:


del animals[-1]
animals


# ```python
# >>> animals_sample = ['dog']
# >>> animals_sample
# ['dog']
# ```
# 
# ```python
# >>> del animals_sample
# ```
# 
# ```python
# >>> animals_sample
# ---------------------------------------------------------------------------
# NameError                                 Traceback (most recent call last)
# <ipython-input-66-4c8b6fb25c0d> in <module>()
# ----> 1 animals_sample
# 
# NameError: name 'animals_sample' is not defined
# ```

# * `reverse()` 메소드는 리스트의 순서를 뒤집는다.

# In[59]:


print('기존 동물 리스트', animals)
animals.reverse()
print('뒤집어진 동물 리스트', animals)


# * `sort()` 메소드를 이용하여 리스트의 항목들을 정렬할 수 있다.  
#   * 숫자의 경우는 크기 순서대로
#   * 문자열의 경우는 사전식으로 

# In[60]:


print('기존 동물 리스트', animals)
animals.sort()
print('정렬된 동물 리스트', animals)


# 주의) `sort()`와 `reverse()` 메소드는 원래의 리스트 자체를 변경한다.  
# 

# * `count()` 메소드는 리스트 안에 있는 특정 항목의 개수를 리턴한다.

# In[61]:


animals.extend(['pig', 'pig', 'pig'])
animals


# In[62]:


animals.count('pig')


# ## 리스트 조건제시법
# 
# 주어진 리스트를 이용하여 특정 성질을 만족하는 새로운 리스트를 생성하고자 할 때, **리스트 조건제시법**(List Comprehension)을 활용하면 매우 효율적인 코딩을 할 수 있다.  
# 
# 리스트 조건제시법은 집합을 정의할 때 사용하는 조건제시법과 매우 유사하다.  
# 예를 들어, 0과 10사이에 있는 홀수들의 제곱을 원소로 갖는 집합을 정의하려면 두 가지 방법을 활용할 수 있다.  
# 
# * 원소나열법  
# $\{1, \ 9, \ 25, \ 49, \ 81\}$
# 
# * 조건제시법  
# $\{ x^2 \ |\ 0 \le x \le 10, \ 단 \ x는 \ 홀수 \}$
# 
# 여기서는 조건제시법을 활용하여 새로운 리스트를 생성하는 방법을 알아본다.

# 0과 10사이에 있는 홀수들의 제곱을 순서대로 담고 있는 리스트는 어떻게 구현할까? 

# In[63]:


squares = [1, 9, 25, 49, 81]
squares


# 반복문을 활용할 수도 있다.  
# * `while` 반복문 : 리스트의 `append()` 메소드를 활용한다. 

# In[64]:


i = 0
squares = []

while i <= 10 :
    if i % 2 == 1 :
        squares.append(i**2)
    i += 1

print(squares)


# * `for` 반복문 : `range()` 함수를 활용한다.

# In[65]:


squares = []

for k in range(11) :
    if k % 2 == 1 :
        squares.append(k**2)

print(squares)


# 주의) 위의 코드는 `k`라는 변수를 만들고, 이는 반복문이 종료된 다음에도 남아 있다. 

# In[66]:


print(k)


# 이제 리스트를 좀 더 간결하고 읽기 쉽게 정의하는 방법인 리스트 조건제시법을 살펴보자.  
# 
# 리스트 조건제시법은 집합 정의에 사용되는 조건제시법과 매우 비슷하게 작동한다. 예를 들어, 0부터 10 사이의 홀수들의 제곱을 순서대로 항목으로 갖는 리스트를 생성하는 과정을 통해 조건제시법을 살펴보자.  
# 
# * 0부터 10 사이의 홀수들의 제곱을 원소로 갖는 집합을 조건제시법으로 표현한다.  
# > `{ x^2  | 0 <= x <= 10, 단 x는 홀수}`
# 
# * 집합 기호를 리스트 기호로 대체한다.  
# > `[ x^2  | 0 <= x <= 10, 단 x는 홀수]`
# 
# * 집합의 짝대기($|$) 기호는 `for` 로 대체한다.  
# > `[ x^2  for 0 <= x <= 10, 단 x는 홀수]`
# 
# * 짝대기 기호 왼편에 위치한 `x^2`를 파이썬 수식으로 변경한다. 즉, `x ** 2`로 변경한다.   
# > `[ x**2  for 0 <= x <= 10, 단 x는 홀수]`
# 
# * 짝대기 기호 오른편에 위치하고, 변수 `x`가 어느 범위에서 움직이는지를 설명하는 부등식인 `0 <= x <= 10` 부분을 파이썬 수식으로 변경한다. 주로, 기존에 정의된 리스트를 사용하거나 `range()` 함수를 사용하여 범위를 `x in ...` 형식으로 지정한다.   
# > `[ x**2  for x in range(11), 단 x는 홀수]`
# 
# * 마지막으로 변수 `x`에 대한 제한조건인 `단 x는 홀수` 부분을 파이썬의 `if` 문장으로 변경한다. 예를 들어, `x는 홀수`는 파이썬의 `x % 2 == 1`로 나타낼 수 있다.   
# > `[ x**2  for x in range(11) if x % 2 == 1]`
# 

# In[67]:


squares = [x**2 for x in range(11) if x % 2 == 1]
squares


# ex) 0부터 10사이에 홀수들을 항목으로 갖는 리스트를 조건제시법으로 생성하여라. 

# In[68]:


odd_10 = [x for x in range(11) if x % 2 == 1]
odd_10


# 아래와 같이 코드를 작성할 수도 있다.

# In[69]:


odd_10 = [2*x + 1 for x in range(5)]
odd_10


# ex) 0부터 10사이의 홀수들의 세제곱을 항목으로 갖는 리스트를 조건제시법으로 구현하여라.

# In[70]:


odd_10_cube = [x**3 for x in range(11) if x % 2 == 1]
odd_10_cube


# 아래와 같이 기존에 정의된 리스트를 사용할 수도 있다.

# In[71]:


odd_10_cube = [x**3 for x in odd_10]
odd_10_cube


# ex) 수학에서 사용되는 대표적인 지수함수인 $f(x) = e^x$ 는 `math` 모듈의 `exp()`로 정의되어 있다. 아래 리스트를 조건제시법으로 구현하여라.  
# 
# <center> $[e^1, e^3, e^5, e^7, e^9]$ </center>
# 
# 주의) $e$의 값은 대략 2.718 정도이다. 

# In[72]:


from math import exp


# In[73]:


[exp(n) for n in range(10) if n % 2 == 1]

